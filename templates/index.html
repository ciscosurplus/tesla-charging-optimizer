<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tesla Charging Optimizer</title>
    <link rel="stylesheet" href="/static/style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRWIZYWD7Occij6YpSk14c18GWClOLPAGzghw&s" alt="Tesla Model Y" class="car-logo">
            <h1>Tesla Charging Optimizer</h1>
            <p class="subtitle">Find the cheapest Octopus Agile slots</p>
        </header>

        <section class="status-section">
            <h2>Current Status</h2>
            <div class="status-grid info-grid">
                <div class="status-card">
                    <div class="status-label">Battery Level</div>
                    <div class="status-value" id="battery-level">--</div>
                    <div class="status-sublabel" id="battery-range"></div>
                </div>
                <div class="status-card">
                    <div class="status-label">Charging State</div>
                    <div class="status-value" id="charging-state">--</div>
                </div>
                <div class="status-card">
                    <div class="status-label">Energy Needed</div>
                    <div class="status-value" id="energy-needed">--</div>
                    <div class="status-sublabel" id="slots-needed"></div>
                </div>
            </div>
            <div class="status-grid input-grid">
                <div class="status-card">
                    <div class="status-label">Target Charge</div>
                    <div class="target-input">
                        <input type="number" id="target-percent" value="{{ default_target }}" min="0" max="100" step="5">
                        <span>%</span>
                    </div>
                </div>
                <div class="status-card">
                    <div class="status-label">Depart By</div>
                    <select id="departure-time" class="departure-select">
                        <option value="">No deadline</option>
                        <!-- Options populated by JavaScript -->
                    </select>
                    <div class="status-sublabel" id="departure-status">Charge anytime</div>
                </div>
            </div>
            <button id="calculate-btn" class="primary-btn">Calculate Optimal Slots</button>
        </section>

        <section class="schedule-section" id="schedule-section" style="display: none;">
            <h2>Optimal Charging Schedule</h2>
            <div class="schedule-summary" id="schedule-summary"></div>
            <div class="schedule-list" id="schedule-list"></div>
        </section>

        <section class="rates-section">
            <h2>Available Rates <span class="rate-coverage-badge" id="rate-coverage-badge"></span></h2>
            <div class="rate-chart-container">
                <canvas id="rate-chart"></canvas>
            </div>
            <div class="rates-table-container">
                <table class="rates-table" id="rates-table">
                    <thead>
                        <tr>
                            <th>Time</th>
                            <th>Rate (p/kWh)</th>
                            <th>Cost for 3.5kWh</th>
                        </tr>
                    </thead>
                    <tbody id="rates-body">
                        <tr><td colspan="3">Loading...</td></tr>
                    </tbody>
                </table>
            </div>
        </section>

        <footer>
            <p>Data from Home Assistant | Tesla Model Y LR (75kWh) | 7kW Charger</p>
            <p class="last-updated">Last updated: <span id="last-updated">--</span></p>
        </footer>
    </div>

    <script>
        const KWH_PER_SLOT = 3.5;
        const BATTERY_CAPACITY = 75;
        let currentRates = [];
        let selectedSlots = [];
        let rateChart = null;
        let departureTime = null;

        async function fetchStatus() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();

                // Update Tesla status
                if (data.tesla && !data.tesla.error) {
                    document.getElementById('battery-level').textContent =
                        data.tesla.battery_percent.toFixed(0) + '%';

                    if (data.tesla.range_miles) {
                        document.getElementById('battery-range').textContent =
                            data.tesla.range_miles.toFixed(0) + ' miles range';
                    }

                    document.getElementById('charging-state').textContent =
                        data.tesla.charging_state || 'Unknown';
                } else {
                    document.getElementById('battery-level').textContent = 'Error';
                    document.getElementById('charging-state').textContent =
                        data.tesla?.error || 'Unable to fetch';
                }

                // Update rates table
                if (data.rates && !data.rates.error) {
                    currentRates = data.rates;
                    updateRatesTable(data.rates);
                    // Render rate chart
                    const depTime = document.getElementById('departure-time').value ?
                        new Date(document.getElementById('departure-time').value).toISOString() : null;
                    renderRateChart(data.rates, [], depTime);
                }

                // Update rate coverage badge
                if (data.rates_info) {
                    updateRateCoverageBadge(data.rates_info);
                }

                // Calculate initial energy needed
                updateEnergyNeeded();

                // Update last updated timestamp
                const now = new Date();
                document.getElementById('last-updated').textContent =
                    now.toLocaleTimeString('en-GB', {
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
            } catch (error) {
                console.error('Error fetching status:', error);
            }
        }

        function updateRateCoverageBadge(ratesInfo) {
            const badge = document.getElementById('rate-coverage-badge');
            if (!badge) return;

            let text = '';
            let badgeClass = 'rate-coverage-badge';

            if (ratesInfo.includes_today && ratesInfo.includes_tomorrow) {
                text = 'Today + Tomorrow';
                badgeClass += ' badge-full';
            } else if (ratesInfo.includes_tomorrow) {
                text = 'Tomorrow only';
                badgeClass += ' badge-partial';
            } else if (ratesInfo.includes_today) {
                text = 'Today only';
                badgeClass += ' badge-partial';
            } else {
                text = 'No rates';
                badgeClass += ' badge-error';
            }

            badge.textContent = text;
            badge.className = badgeClass;
        }

        function renderRateChart(rates, optimalSlots = [], departureTimeISO = null) {
            const ctx = document.getElementById('rate-chart').getContext('2d');

            // Store selected slots for highlighting
            selectedSlots = optimalSlots;

            // Find current time index
            const now = new Date();
            let currentTimeIndex = -1;

            // Prepare data
            const labels = rates.map((r, i) => {
                const time = new Date(r.start);
                if (time <= now && new Date(r.end) > now) {
                    currentTimeIndex = i;
                }
                return time.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
            });

            const data = rates.map(r => r.rate);

            // Create set of optimal slot starts for quick lookup
            const optimalStarts = new Set(optimalSlots.map(s => s.start));

            // Generate colors based on rate value and optimal status
            const backgroundColors = rates.map((r, i) => {
                const startTime = new Date(r.start);
                const isPast = new Date(r.end) < now;
                const isOptimal = optimalStarts.has(r.start);
                const isAfterDeparture = departureTimeISO && new Date(r.start) >= new Date(departureTimeISO);

                if (isOptimal) return 'rgba(16, 185, 129, 0.9)';
                if (isPast) return 'rgba(100, 100, 100, 0.3)';
                if (isAfterDeparture) return 'rgba(100, 100, 100, 0.2)';
                if (r.rate < 10) return 'rgba(16, 185, 129, 0.6)';
                if (r.rate < 20) return 'rgba(245, 158, 11, 0.6)';
                if (r.rate < 30) return 'rgba(249, 115, 22, 0.6)';
                return 'rgba(239, 68, 68, 0.6)';
            });

            const borderColors = rates.map(r => {
                return optimalStarts.has(r.start) ? '#10b981' : 'transparent';
            });

            const borderWidths = rates.map(r => {
                return optimalStarts.has(r.start) ? 2 : 0;
            });

            // Build annotations
            const annotations = {};

            // Current time marker
            if (currentTimeIndex >= 0) {
                annotations.currentTime = {
                    type: 'line',
                    xMin: currentTimeIndex,
                    xMax: currentTimeIndex,
                    borderColor: '#e31937',
                    borderWidth: 2,
                    label: {
                        display: true,
                        content: 'NOW',
                        position: 'start',
                        backgroundColor: '#e31937',
                        color: '#fff',
                        font: { size: 10, weight: 'bold' }
                    }
                };
            }

            // Departure time marker
            if (departureTimeISO) {
                const departureDate = new Date(departureTimeISO);
                let departureIndex = rates.findIndex(r => new Date(r.start) >= departureDate);
                if (departureIndex === -1) departureIndex = rates.length - 1;

                annotations.departureTime = {
                    type: 'line',
                    xMin: departureIndex,
                    xMax: departureIndex,
                    borderColor: '#3b82f6',
                    borderWidth: 2,
                    borderDash: [6, 4],
                    label: {
                        display: true,
                        content: 'DEPART',
                        position: 'start',
                        backgroundColor: '#3b82f6',
                        color: '#fff',
                        font: { size: 10, weight: 'bold' }
                    }
                };
            }

            // Day boundary markers
            let prevDate = null;
            rates.forEach((r, i) => {
                const date = new Date(r.start).toDateString();
                if (prevDate && date !== prevDate) {
                    annotations[`day${i}`] = {
                        type: 'line',
                        xMin: i,
                        xMax: i,
                        borderColor: 'rgba(255, 255, 255, 0.3)',
                        borderWidth: 1,
                        borderDash: [5, 5]
                    };
                }
                prevDate = date;
            });

            // Destroy existing chart if it exists
            if (rateChart) {
                rateChart.destroy();
            }

            // Create new chart
            rateChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Rate (p/kWh)',
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: borderWidths,
                        borderRadius: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        annotation: { annotations: annotations },
                        tooltip: {
                            callbacks: {
                                title: (items) => {
                                    const rate = rates[items[0].dataIndex];
                                    const isOptimal = optimalStarts.has(rate.start);
                                    const time = items[0].label;
                                    return isOptimal ? `â˜… ${time} (Optimal)` : time;
                                },
                                label: (item) => {
                                    return `${item.raw.toFixed(2)}p/kWh`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#333', display: false },
                            ticks: {
                                color: '#888',
                                maxRotation: 0,
                                autoSkip: true,
                                maxTicksLimit: 12
                            }
                        },
                        y: {
                            grid: { color: '#333' },
                            ticks: {
                                color: '#888',
                                callback: (value) => value + 'p'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function updateRatesTable(rates) {
            const tbody = document.getElementById('rates-body');
            const now = new Date();

            if (!rates || rates.length === 0) {
                tbody.innerHTML = '<tr><td colspan="3">No rates available</td></tr>';
                return;
            }

            tbody.innerHTML = rates.map(rate => {
                const startTime = new Date(rate.start);
                const endTime = new Date(rate.end);
                const isPast = endTime < now;
                const isCurrent = startTime <= now && endTime > now;
                const isSelected = selectedSlots.some(s => s.start === rate.start);

                const timeStr = startTime.toLocaleTimeString('en-GB', {
                    hour: '2-digit',
                    minute: '2-digit'
                }) + ' - ' + endTime.toLocaleTimeString('en-GB', {
                    hour: '2-digit',
                    minute: '2-digit'
                });

                const cost = (rate.rate * KWH_PER_SLOT).toFixed(2);
                const rateClass = getRateClass(rate.rate);

                let rowClass = rateClass;
                if (isPast) rowClass += ' past';
                if (isCurrent) rowClass += ' current';
                if (isSelected) rowClass += ' selected';

                return `<tr class="${rowClass}">
                    <td>${timeStr}</td>
                    <td>${rate.rate.toFixed(2)}p</td>
                    <td>${cost}p</td>
                </tr>`;
            }).join('');
        }

        function getRateClass(rate) {
            if (rate < 10) return 'rate-low';
            if (rate < 20) return 'rate-medium';
            if (rate < 30) return 'rate-high';
            return 'rate-very-high';
        }

        function updateEnergyNeeded() {
            const batteryText = document.getElementById('battery-level').textContent;
            const currentPercent = parseFloat(batteryText) || 0;
            const targetPercent = parseInt(document.getElementById('target-percent').value) || 80;

            const percentNeeded = Math.max(0, targetPercent - currentPercent);
            const kwhNeeded = (percentNeeded / 100) * BATTERY_CAPACITY;
            const slotsNeeded = Math.ceil(kwhNeeded / KWH_PER_SLOT);

            document.getElementById('energy-needed').textContent = kwhNeeded.toFixed(1) + ' kWh';
            document.getElementById('slots-needed').textContent = slotsNeeded + ' slots needed';
        }

        async function calculateOptimal() {
            const target = document.getElementById('target-percent').value;
            const btn = document.getElementById('calculate-btn');
            btn.disabled = true;
            btn.textContent = 'Calculating...';

            try {
                let url = `/api/calculate?target=${target}`;
                const departureInput = document.getElementById('departure-time').value;
                if (departureInput) {
                    const departureDate = new Date(departureInput);
                    url += `&departure_time=${encodeURIComponent(departureDate.toISOString())}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    alert('Error: ' + data.error);
                    return;
                }

                selectedSlots = data.slots || [];
                displaySchedule(data);
                updateRatesTable(currentRates);

                // Update chart with optimal slots
                if (data.slots && data.slots.length > 0) {
                    const statusData = await fetch('/api/status').then(r => r.json());
                    if (statusData.rates) {
                        const depTime = document.getElementById('departure-time').value ?
                            new Date(document.getElementById('departure-time').value).toISOString() : null;
                        renderRateChart(statusData.rates, data.slots, depTime);
                    }
                }
            } catch (error) {
                console.error('Error calculating:', error);
                alert('Failed to calculate optimal slots');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Calculate Optimal Slots';
            }
        }

        function displaySchedule(data) {
            const section = document.getElementById('schedule-section');
            const summary = document.getElementById('schedule-summary');
            const list = document.getElementById('schedule-list');

            if (data.slots_needed === 0) {
                summary.innerHTML = `
                    <div class="summary-message success">
                        Battery already at or above target (${data.target_percent}%)
                    </div>`;
                list.innerHTML = '';
                section.style.display = 'block';
                return;
            }

            const blockCount = data.blocks.length;
            const blockLabel = blockCount === 1 ? 'Block' : 'Blocks';

            // Show warning if present
            let warningHtml = '';
            if (data.warning) {
                warningHtml = `<div class="warning-message">${data.warning}</div>`;
            }

            summary.innerHTML = warningHtml + `
                <div class="summary-stats">
                    <div class="stat">
                        <span class="stat-value">${data.kwh_needed} kWh</span>
                        <span class="stat-label">Energy needed</span>
                    </div>
                    <div class="stat">
                        <span class="stat-value">${blockCount}</span>
                        <span class="stat-label">${blockLabel} (${data.slots_needed} slots)</span>
                    </div>
                    <div class="stat highlight">
                        <span class="stat-value">&pound;${data.total_cost_pounds.toFixed(2)}</span>
                        <span class="stat-label">Total cost</span>
                    </div>
                </div>
                <div class="charge-change">
                    ${data.current_percent.toFixed(0)}% &rarr; ${data.target_percent}%
                </div>`;

            list.innerHTML = data.blocks.map(block => {
                const startTime = new Date(block.start);
                const endTime = new Date(block.end);
                const timeStr = startTime.toLocaleTimeString('en-GB', {
                    hour: '2-digit',
                    minute: '2-digit'
                }) + ' - ' + endTime.toLocaleTimeString('en-GB', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
                const duration = block.slot_count * 30;
                const hours = Math.floor(duration / 60);
                const mins = duration % 60;
                const durationStr = hours > 0 ? `${hours}h${mins > 0 ? ` ${mins}m` : ''}` : `${mins}m`;

                return `<div class="schedule-block ${getRateClass(block.avg_rate)}">
                    <div class="block-header">
                        <span class="block-time">${timeStr}</span>
                        <span class="block-duration">${durationStr}</span>
                    </div>
                    <div class="block-details">
                        <span class="block-energy">${block.kwh.toFixed(1)} kWh</span>
                        <span class="block-rate">avg ${block.avg_rate.toFixed(1)}p/kWh</span>
                        <span class="block-cost">${(block.total_cost_pence / 100).toFixed(2)}</span>
                    </div>
                </div>`;
            }).join('');

            section.style.display = 'block';
        }

        // Event listeners
        document.getElementById('calculate-btn').addEventListener('click', calculateOptimal);
        document.getElementById('target-percent').addEventListener('change', updateEnergyNeeded);

        // Initial load
        fetchStatus();

        // Refresh status every 5 minutes
        setInterval(fetchStatus, 5 * 60 * 1000);

        // Populate departure time dropdown options
        function populateDepartureOptions() {
            const select = document.getElementById('departure-time');
            const now = new Date();

            // Clear existing options except the first one
            while (select.options.length > 1) {
                select.remove(1);
            }

            // Round up to next 30-min block
            const minutes = now.getMinutes();
            const nextSlot = new Date(now);
            if (minutes < 30) {
                nextSlot.setMinutes(30, 0, 0);
            } else {
                nextSlot.setHours(nextSlot.getHours() + 1, 0, 0, 0);
            }

            // Generate slots until 23:30 tomorrow
            const tomorrow = new Date(now);
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setHours(23, 30, 0, 0);

            const today = now.toDateString();
            let current = new Date(nextSlot);

            while (current <= tomorrow) {
                const timeStr = current.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                const dayLabel = current.toDateString() === today ? 'Today' : 'Tomorrow';
                const option = document.createElement('option');
                option.value = current.toISOString();
                option.textContent = `${timeStr} ${dayLabel}`;
                select.appendChild(option);

                current.setMinutes(current.getMinutes() + 30);
            }
        }

        // Departure time handling
        document.getElementById('departure-time').addEventListener('change', function() {
            const value = this.value;
            const statusEl = document.getElementById('departure-status');

            if (value) {
                const dt = new Date(value);
                statusEl.textContent = dt.toLocaleString('en-GB', {
                    weekday: 'short',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                departureTime = dt.toISOString();
            } else {
                statusEl.textContent = 'Charge anytime';
                departureTime = null;
            }

            // Re-render chart with departure marker
            if (currentRates.length > 0) {
                renderRateChart(currentRates, selectedSlots, departureTime);
            }
        });

        // Initialize departure dropdown on page load
        populateDepartureOptions();
    </script>
</body>
</html>
